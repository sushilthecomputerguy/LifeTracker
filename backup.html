<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Backup & Restore</title>
        <link rel="stylesheet" href="styles.css">
<link rel="manifest" href="manifest.json">
<meta name="theme-color" content="#fef5eb">
<link rel="icon" href="favicon.ico" type="image/x-icon">
    
</head>
<body>
        <button class="theme-toggle" aria-label="Switch to dark mode">ğŸŒ™</button>

<div class="container">
    <h1>Backup &amp; Restore</h1>

    <!-- â•â•â• EXPORT â•â•â• -->
    <div class="section">
        <h2 class="section-title">Export Backup</h2>
        <p class="section-desc">
            Downloads every tracker and all your daily entries as one JSON file.
            Each date in the file includes the tracker name, type, and the actual saved value â€” fully readable without the app.
        </p>

        <button class="btn btn-primary" onclick="exportBackup()">ğŸ“¥ Download Backup</button>

        <div class="box box-info">
            <div class="box-title">What is saved in the file?</div>
            âœ“ All trackers with their full settings (options, prefix/suffix, etc.)<br>
            âœ“ Every tracked date with each entry resolved: tracker name + value<br>
            âœ“ Custom templates<br>
            âœ“ Export date &amp; version metadata
        </div>

        <div class="box box-success" id="exportSuccess">
            <div class="box-title">âœ“ Success</div>
            <span id="exportSuccessText"></span>
        </div>
    </div>

    <!-- â•â•â• IMPORT â•â•â• -->
    <div class="section">
        <h2 class="section-title">Import Backup</h2>
        <p class="section-desc">
            Drop or choose a backup JSON file. A full preview of trackers and every date will appear before anything is written.
        </p>

        <!-- drop zone -->
        <div class="drop-zone" id="dropZone">
            <div class="icon">ğŸ“</div>
            <div class="hint">Drag &amp; drop your backup file here</div>
            <div class="hint dim">or</div>
            <button class="btn btn-success" onclick="document.getElementById('fileInput').click()">Choose File</button>
            <input type="file" id="fileInput" class="file-input" accept=".json" onchange="onFileChosen(event)">
        </div>

        <!-- mode -->
        <div class="radio-group">
            <label>
                <input type="radio" name="importMode" value="merge" checked>
                <div>
                    <div class="radio-label">Merge</div>
                    <div class="radio-desc">Keep current data and add everything from the backup on top.</div>
                </div>
            </label>
            <label>
                <input type="radio" name="importMode" value="replace">
                <div>
                    <div class="radio-label">Replace</div>
                    <div class="radio-desc">Delete all current data first, then load the backup. Best for a fresh device.</div>
                </div>
            </label>
        </div>

        <!-- preview (hidden until file loaded) -->
        <div class="preview-panel" id="previewPanel">
            <!-- tracker definitions -->
            <div class="preview-trackers-title">Trackers in this backup</div>
            <div id="previewTrackerList"></div>

            <!-- date entries -->
            <div id="previewDates" style="margin-top:18px;"></div>
        </div>

        <!-- import button -->
        <div class="import-btn-row" id="importBtnRow">
            <button class="btn btn-primary" onclick="runImport()">ğŸ“¥ Import</button>
        </div>

        <!-- messages -->
        <div class="box box-warn">
            <div class="box-title">âš ï¸ Important</div>
            "Replace" permanently deletes everything currently on this device. Export a fresh backup first if you need to keep current data.
        </div>

        <div class="box box-success" id="importSuccess">
            <div class="box-title">âœ“ Import successful</div>
            <span id="importSuccessText"></span>
        </div>

        <div class="box box-error" id="importError">
            <div class="box-title">âœ— Import failed</div>
            <span id="importErrorText"></span>
        </div>
    </div>
</div>


<div class="bottom-navigation">
            <div><a href="trackers.html"><img src="folder_icon.png"/><br/>Tracker</a></div>
            <div><a href="report.html"><img src="calendar_small.png"/><br/>Report</a></div>
            <div><a href="index.html"><img src="today_small.png"/><br/>My Day</a></div>
            <div><a href="settings.html"><img src="setting_icon.png"/><br/>Settings</a></div>
        </div>

<script>
/* â•â•â• DB â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
let db;
const DB_NAME    = 'TrackerDB';
const STORE_NAME = 'trackers';

function initDB() {
    const req = indexedDB.open(DB_NAME, 2);
    req.onerror   = () => console.error('DB open failed');
    req.onsuccess = () => { db = req.result; };
    req.onupgradeneeded = (e) => {
        const d = e.target.result;
        if (!d.objectStoreNames.contains(STORE_NAME)) {
            const s = d.createObjectStore(STORE_NAME, { keyPath:'id', autoIncrement:true });
            s.createIndex('title','title');
            s.createIndex('type','type');
        }
    };
}

function getAllTrackers() {
    return new Promise((res, rej) => {
        const req = db.transaction([STORE_NAME],'readonly').objectStore(STORE_NAME).getAll();
        req.onsuccess = () => res(req.result);
        req.onerror   = () => rej(req.error);
    });
}

function addTracker(tracker) {
    return new Promise((res, rej) => {
        const req = db.transaction([STORE_NAME],'readwrite').objectStore(STORE_NAME).add(tracker);
        req.onsuccess = () => res(req.result);   // new auto-inc id
        req.onerror   = () => rej(req.error);
    });
}

function clearDB() {
    return new Promise((res, rej) => {
        const req = db.transaction([STORE_NAME],'readwrite').objectStore(STORE_NAME).clear();
        req.onsuccess = res;
        req.onerror   = () => rej(req.error);
    });
}

/* â•â•â• tiny helpers â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function getTypeLabel(t) {
    return { dropdown:'Dropdown', yesno:'Yes / No', numeric:'Numeric', text:'Text' }[t] || 'Dropdown';
}

function formatDate(isoDate) {
    // "2026-02-03" â†’ "February 3, 2026"
    const d = new Date(isoDate + 'T00:00:00');
    return d.toLocaleDateString('en-US', { year:'numeric', month:'long', day:'numeric' });
}

/*
 * Given a tracker object and the raw value string stored in dailySelections,
 * return a human-readable string.  e.g.  "Happy"  /  "Yes"  /  "$150 lbs"  /  "note text"
 */
function resolveValue(tracker, rawValue) {
    const type = tracker.type || 'dropdown';

    if (type === 'dropdown') {
        const idx = parseInt(rawValue);
        return (tracker.options && tracker.options[idx]) ? tracker.options[idx].title : rawValue;
    }
    if (type === 'yesno')  return rawValue === 'yes' ? 'Yes' : 'No';
    if (type === 'numeric') {
        const p = tracker.numericPrefix || '';
        const s = tracker.numericSuffix || '';
        return `${p}${rawValue}${s ? ' ' + s : ''}`;
    }
    return rawValue; // text
}

/* â•â•â• EXPORT â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
async function exportBackup() {
    try {
        const trackers       = await getAllTrackers();
        const dailySelections = JSON.parse(localStorage.getItem('dailySelections') || '{}');
        const customTemplates = JSON.parse(localStorage.getItem('customTemplates')  || '[]');

        // Build a tracker-id â†’ tracker map for quick lookup
        const trackerMap = {};
        trackers.forEach(t => { trackerMap[t.id] = t; });

        /*
         * Build the "dates" array.
         * Each element  = { date, dateFormatted, entries: [ â€¦ ] }
         * Each entry    = { trackerId, trackerName, trackerType, value (resolved), rawValue }
         * Sorted newest date first.
         */
        const sortedDates = Object.keys(dailySelections).sort().reverse();

        const dates = sortedDates.map(dateKey => {
            const dayEntries = dailySelections[dateKey];
            const entries = Object.values(dayEntries).map(entry => {
                const tracker = trackerMap[entry.trackerId];
                return {
                    trackerId:   entry.trackerId,
                    trackerName: tracker ? tracker.title : 'Unknown Tracker',
                    trackerType: tracker ? (tracker.type || 'dropdown') : entry.type,
                    value:       tracker ? resolveValue(tracker, entry.value) : entry.value,
                    rawValue:    entry.value
                };
            });

            return {
                date:          dateKey,           // "2026-02-03"  â€” the machine key
                dateFormatted: formatDate(dateKey), // "February 3, 2026"
                entries:       entries
            };
        });

        /* final JSON payload */
        const backup = {
            version:    '2.0',
            exportDate: new Date().toISOString(),
            data: {
                trackers:        trackers,
                dates:           dates,
                customTemplates: customTemplates
            }
        };

        /* download */
        const blob = new Blob([JSON.stringify(backup, null, 2)], { type:'application/json' });
        const url  = URL.createObjectURL(blob);
        const a    = document.createElement('a');
        a.href     = url;
        a.download = `tracker-backup-${new Date().toISOString().split('T')[0]}.json`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);

        showMsg('exportSuccess','exportSuccessText', 'Backup downloaded. The file contains all trackers and every tracked date.');

    } catch (err) {
        console.error('Export error', err);
    }
}

/* â•â•â• IMPORT â€“ read file â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
let pendingBackup = null;

function onFileChosen(e) {
    const file = e.target.files[0];
    if (file) readFile(file);
}

/* drag & drop */
const dropZone = document.getElementById('dropZone');
dropZone.addEventListener('dragover',  (e) => { e.preventDefault(); dropZone.classList.add('dragover'); });
dropZone.addEventListener('dragleave', ()  => { dropZone.classList.remove('dragover'); });
dropZone.addEventListener('drop', (e) => {
    e.preventDefault();
    dropZone.classList.remove('dragover');
    const file = e.dataTransfer.files[0];
    if (file) readFile(file);
    else      showMsg('importError','importErrorText','Please drop a valid JSON backup file.');
});

async function readFile(file) {
    hideAll();
    try {
        const text   = await file.text();
        const backup = JSON.parse(text);

        // accept both v2 (dates array) and legacy (dailySelections object)
        if (!backup.version || !backup.data || !backup.data.trackers) {
            throw new Error('Not a valid tracker backup');
        }

        pendingBackup = backup;
        renderPreview(backup);
        document.getElementById('previewPanel').classList.add('show');
        document.getElementById('importBtnRow').classList.add('show');

    } catch (err) {
        console.error('Read error', err);
        showMsg('importError','importErrorText','Invalid file â€” make sure it is a Tracker backup JSON.');
        pendingBackup = null;
        document.getElementById('previewPanel').classList.remove('show');
        document.getElementById('importBtnRow').classList.remove('show');
    }
}

/* â•â•â• PREVIEW â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function renderPreview(backup) {
    const { trackers, dates } = backup.data;

    /* â”€â”€ tracker list â”€â”€ */
    document.getElementById('previewTrackerList').innerHTML = trackers.map(t => {
        const type = t.type || 'dropdown';
        let detail = '';

        if (type === 'dropdown' && t.options) {
            detail = t.options.map(o => `<span class="pill" style="background:${o.color}">${o.title}</span>`).join('');
        } else if (type === 'yesno') {
            detail = '<span style="color:#666;font-size:13px;">Yes or No</span>';
        } else if (type === 'numeric') {
            const p = t.numericPrefix || '';
            const s = t.numericSuffix || '';
            detail = `<span style="color:#666;font-size:13px;">${p}[number]${s ? ' '+s : ''}</span>`;
        } else {
            detail = '<span style="color:#666;font-size:13px;">Free text</span>';
        }

        return `<div class="preview-tracker-row">
                    <span class="type-badge">${getTypeLabel(type)}</span>
                    <span style="font-weight:600;">${t.title}</span>
                    <span style="flex:1;">${detail}</span>
                </div>`;
    }).join('');

    /* â”€â”€ date blocks â”€â”€ */
    // If the file has the new "dates" array use it directly; otherwise rebuild from legacy dailySelections
    let dateBlocks = [];

    if (dates && dates.length) {
        dateBlocks = dates;
    } else if (backup.data.dailySelections) {
        // legacy format â€” resolve on the fly
        const tMap = {};
        trackers.forEach(t => { tMap[t.id] = t; });

        dateBlocks = Object.keys(backup.data.dailySelections).sort().reverse().map(dateKey => {
            const entries = Object.values(backup.data.dailySelections[dateKey]).map(entry => {
                const tracker = tMap[entry.trackerId];
                return {
                    trackerId:   entry.trackerId,
                    trackerName: tracker ? tracker.title : 'Unknown',
                    trackerType: tracker ? (tracker.type || 'dropdown') : (entry.type || 'dropdown'),
                    value:       tracker ? resolveValue(tracker, entry.value) : entry.value,
                    rawValue:    entry.value
                };
            });
            return { date: dateKey, dateFormatted: formatDate(dateKey), entries };
        });
    }

    document.getElementById('previewDates').innerHTML = dateBlocks.length
        ? dateBlocks.map(block => `
            <div class="date-block">
                <div class="date-block-header">${block.dateFormatted} <span style="font-weight:400;color:#666;font-size:13px;">(${block.date})</span></div>
                <div class="date-block-body">
                    ${block.entries.map(e => `
                        <div class="entry-row">
                            <span class="entry-name">${e.trackerName}</span>
                            <span class="type-badge">${getTypeLabel(e.trackerType)}</span>
                            <span class="entry-value">${e.value}</span>
                        </div>`).join('')}
                </div>
            </div>`)
            .join('')
        : '<p style="color:#999;font-size:14px;margin-top:10px;">No tracked dates in this backup.</p>';
}

/* â•â•â• IMPORT â€“ execute â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
async function runImport() {
    if (!pendingBackup) return;
    hideAll();

    const mode = document.querySelector('input[name="importMode"]:checked').value;
    if (mode === 'replace') {
        if (!confirm('Replace will permanently delete all data on this device. Continue?')) return;
        await clearDB();
        localStorage.removeItem('dailySelections');
        localStorage.removeItem('customTemplates');
    }

    try {
        const { trackers, dates, customTemplates } = pendingBackup.data;
        const legacySelections = pendingBackup.data.dailySelections; // may be undefined (v2 uses dates)

        /* â”€â”€ 1. re-insert trackers, build oldId â†’ newId map â”€â”€ */
        const idMap = {};
        if (trackers && trackers.length) {
            for (const t of trackers) {
                const oldId = t.id;
                const copy  = { ...t };
                delete copy.id;
                const newId = await addTracker(copy);
                idMap[String(oldId)] = newId;
            }
        }

        /* â”€â”€ 2. rebuild dailySelections keyed by date, with remapped ids â”€â”€ */
        let rebuilt = {};

        if (dates && dates.length) {
            // v2 format â€“ dates array with rawValue
            dates.forEach(block => {
                rebuilt[block.date] = {};
                block.entries.forEach(e => {
                    const newId = idMap[String(e.trackerId)] || e.trackerId;
                    rebuilt[block.date][String(newId)] = {
                        trackerId: newId,
                        value:     e.rawValue,
                        type:      e.trackerType,
                        date:      block.date,
                        timestamp: new Date().toISOString()
                    };
                });
            });
        } else if (legacySelections) {
            // legacy format â€“ dailySelections object
            for (const [date, entries] of Object.entries(legacySelections)) {
                rebuilt[date] = {};
                for (const [oldTid, entry] of Object.entries(entries)) {
                    const newId = idMap[String(oldTid)] || oldTid;
                    rebuilt[date][String(newId)] = { ...entry, trackerId: newId };
                }
            }
        }

        /* â”€â”€ 3. write dailySelections â”€â”€ */
        if (mode === 'replace') {
            localStorage.setItem('dailySelections', JSON.stringify(rebuilt));
        } else {
            const existing = JSON.parse(localStorage.getItem('dailySelections') || '{}');
            for (const [date, entries] of Object.entries(rebuilt)) {
                existing[date] = { ...(existing[date] || {}), ...entries };
            }
            localStorage.setItem('dailySelections', JSON.stringify(existing));
        }

        /* â”€â”€ 4. write templates â”€â”€ */
        if (customTemplates) {
            if (mode === 'replace') {
                localStorage.setItem('customTemplates', JSON.stringify(customTemplates));
            } else {
                const existing = JSON.parse(localStorage.getItem('customTemplates') || '[]');
                localStorage.setItem('customTemplates', JSON.stringify([...existing, ...customTemplates]));
            }
        }

        /* â”€â”€ done â”€â”€ */
        showMsg('importSuccess','importSuccessText','All trackers and every date have been restored. Open My Day to see your data.');

        pendingBackup = null;
        document.getElementById('fileInput').value = '';
        document.getElementById('previewPanel').classList.remove('show');
        document.getElementById('importBtnRow').classList.remove('show');

    } catch (err) {
        console.error('Import error', err);
        showMsg('importError','importErrorText','Something went wrong. Check the browser console for details.');
    }
}

/* â•â•â• message helpers â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function hideAll() {
    ['exportSuccess','importSuccess','importError'].forEach(id => {
        document.getElementById(id).classList.remove('show');
    });
}

function showMsg(boxId, textId, msg) {
    hideAll();
    document.getElementById(textId).textContent = msg;
    document.getElementById(boxId).classList.add('show');
}

/* â•â•â• boot â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
initDB();
</script>


    <script>
        /**
 * theme.js  â€”  drop this into every page
 *
 * What it does:
 *  1. On load: reads saved preference from localStorage.
 *              Falls back to OS preference (prefers-color-scheme).
 *              Applies data-theme to <html> BEFORE paint (no flash).
 *  2. Toggle:  clicking .theme-toggle cycles light â†” dark and saves choice.
 *  3. Sync:    listens for OS-level changes in case the user switches in
 *              system settings and has no manual preference saved.
 */

(function () {
  const STORAGE_KEY = 'theme';
  const LIGHT = 'light';
  const DARK  = 'dark';

  // â”€â”€ 1. Resolve theme â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  function getSystemTheme() {
    return window.matchMedia('(prefers-color-scheme: dark)').matches ? DARK : LIGHT;
  }

  function getSavedTheme() {
    return localStorage.getItem(STORAGE_KEY); // null if never set
  }

  function resolveTheme() {
    return getSavedTheme() || getSystemTheme();
  }

  // â”€â”€ 2. Apply theme â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  function applyTheme(theme) {
    document.documentElement.setAttribute('data-theme', theme);
    // Update every toggle button icon on the page
    document.querySelectorAll('.theme-toggle').forEach(btn => {
      btn.textContent = theme === DARK ? 'â˜€ï¸' : 'ğŸŒ™';
      btn.setAttribute('aria-label', theme === DARK ? 'Switch to light mode' : 'Switch to dark mode');
    });
  }

  // â”€â”€ 3. Toggle â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  function toggleTheme() {
    const current = document.documentElement.getAttribute('data-theme') || resolveTheme();
    const next    = current === DARK ? LIGHT : DARK;
    localStorage.setItem(STORAGE_KEY, next);
    applyTheme(next);
  }

  // â”€â”€ 4. Wire up toggle buttons (works for buttons added later too) â”€â”€
  //    We use event delegation on <body> so it works even if the button
  //    is injected by JS after DOMContentLoaded.
  function attachToggle() {
    document.body.addEventListener('click', function (e) {
      if (e.target.closest('.theme-toggle')) toggleTheme();
    });
  }

  // â”€â”€ 5. Sync with OS changes (only if user has no saved pref) â”€â”€
  function watchSystemTheme() {
    window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', function (e) {
      if (!getSavedTheme()) {
        applyTheme(e.matches ? DARK : LIGHT);
      }
    });
  }

  // â”€â”€ INIT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Apply before first paint to avoid flash
  applyTheme(resolveTheme());

  // Wire up after DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', attachToggle);
  } else {
    attachToggle();
  }

  watchSystemTheme();
})();
</script>

  <script>
    // Register Service Worker
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('sw.js')
          .then(() => console.log("Service Worker Registered"))
          .catch(err => console.log("SW failed:", err));
      });
    }
  </script>
</body>
</html>